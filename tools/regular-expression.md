[toc]

# 简易教程

## 元字符，限定符，位置符

| char                                 | quantifiers              | position           |
| ------------------------------------ | ------------------------ | ------------------ |
| `\d` 数字                            | `*` 任意个               | `^` 起始           |
| `\D` 非数字                          | `+` 至少1个              | `$` 结束           |
| `\w` 字母或数字或汉字或下划线        | `?`  0个或1个            | `\b` 单词边界      |
| `\W` 非字母或数字或汉字或下划线      | `{n}` n个                | `\B` 非单词边界    |
| `\s` 任意空白字符, 即`[ \f\n\r\t\v]` | `{min,max}` min至max个   | 单词: 连续的\w子串 |
| `\S` 任意非空白字符                  | `{min,}`       至少min个 |                    |
| `.`   任意字符(除\n)                 | `{,max}`       至多      |                    |
|                                      | `~?` 懒惰匹配后缀        |                    |
|                                      |                          |                    |



## 转义符号


| `\-`       | `\_` | `\,`       | `\.`       |
| ---------- | ---- | ---------- | ---------- |
| `\?`       | `\!` | `\*`       | `\+`       |
| `\^`       | `\$` | `\(`, `\)` | `\[`, `\]` |
| `\{`, `\}` | `\\` |            |            |



## 字符类[]

```
[aeiou]                     # a,e,i,o,u中的任意一个
[0-9]                       # 等同于\d
[0-9a-zA-Z_]                # 1个数字、字母或者下划线
[0-9a-zA-Z_]+               # 1个或多个~
[a-zA-Z\_][0-9a-zA-Z\_]*    # 首字符为字母或下划线,即py合法变量名

[^x]                        # 除x的任意字符
[^aeiou]                    # 除a,e,i,o,u的任意字符
```



## 分枝条件|

```
(P|p)ython                  # python or Python
0\d{2}-\d{8}|0\d{3}-\d{7}   # 027-87654321 or 0717-7654321

```



## 分组

```
(\d{1,3}\.){3}\d{1,3}           # 简单的IP地址匹配
((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)   # 完整的IP地址匹配

\b(\w+)\b\s+\1\b		          # go go
#(\w+)将\w+捕获至分组1,之后的\1调用捕获内容

\b(?<Word>\w+)\b\s+\k<Word>\b	# 自定义分组名
```

**分组语法**

| **捕获** | `(exp)`        | 匹配exp,并捕获文本到自动命名的组里             |
| -------- | -------------- | ---------------------------------------------- |
|          | `(?<name>exp)` | 匹配exp,并捕获文本到名称为name的组里           |
|          | `(?:exp)`      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号 |
| 零宽断言 | `(?=exp)`      | 匹配exp前面的位置                              |
|          | `(?<=exp)`     | 匹配exp后面的位置                              |
|          | `(?!exp)`      | 匹配后面不是exp的位置                          |
|          | `(?<!exp)`     | 匹配前面不是exp的位置                          |
| 注释     | `(?#comment)`  |                                                |



## 零宽断言

零宽表示并不匹配任何字符，断言表示验证条件是否为真。

### 正向零宽断言

```
# 后条件
\b\w+(?=ing\b)      # 从' reading listening '匹配'read', 'listen'

^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$  # 强密码(必须包含大小写字母和数字的组合,不能使用特殊字符,长度在 8-10 之间)
# 起始位置之后的3个正向零宽断言分别验证包含了数字,小写字母和大写字母

# 前条件
(?<=\bmono)\w+\b	# 从' monorail monopoly '匹配'rail', 'poly'
```

类似于`(?<=A|B|C)`的正向零宽断言可以写为`(?:(?<=A)|(?<=B)|(?<=C))`，例如：

```python

```



### 负向零宽断言

```
# 后禁止
\d{3}(?!\d)         # 匹配3位数字且之后不能是数字

# 前禁止
(?<![a-z])\d{7}     # 匹配3位数字且之前不能是小写字母 
```

类似于`(?<!A|B|C)`的负向零宽断言可以写为`(?<!A)|(?<!B)|(?<!C)`，例如：

```

```



### 正向或负向零宽断言(look-around)

```python
>>> re.sub(r'\s+(?=[^\[\(]*\))|(?<=\()\s+', '', 'abcd (  ()e(e w  )f ) gh')
'abcd (()e(ew)f) gh'
```





## 贪婪和懒惰匹配

```python
# *+为贪婪匹配
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')         # \d+直接匹配到结束
>>> re.match(r'^(\d*)(0*)$', '102300').groups()
('102300', '')

# *,+,?,{n,m}接?以懒惰匹配,即尽可能少匹配
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')         # \d+?仅匹配'1023',剩余的'00'留给0*
    
```



## 处理选项

```python
IgnoreCase 忽略大小写
```



## 常用正则表达式

```
# 空白行
\n\s*\r

# 中文字符
[\u4e00-\u9fff]

# ip地址
((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

# 国内电话号码
\d{3}-\d{8}|\d{4}-\d{7}

# 强密码(必须包含大小写字母,数字)
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$

# (http/https) url
https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)
```





# 各语言标准库

## Python标准库：re

### `compile()`

将正则表达式编译为一个正则表达式对象，可以用于匹配。对于需要多次使用的正则表达式，使用`re.compile()`编译这个正则对象以便于复用，可以让程序更加高效。

```python
>>> tel = re.compile(r'^\d{3,4}\-\d{3,8}$')
>>> tel.match('0716-8834387')
<_sre.SRE_Match object at 0x1041b1ac0>
```



### `findall()`

对字符串从左到右扫描，返回所有字符不重复的正则表达式匹配项列表。

```python
>>> re.findall(r'\d{3}', '123456789')
['123', '456', '789']
>>> re.findall(r'\d{3,5}', '123456789')
['12345', '6789']
```



### `finditer()`

与`findall()`相同，返回一个保存了匹配对象的迭代器。

```python
>>> it = re.finditer(r'\d{3}', '123456789')
>>> list(it)
[<re.Match object; span=(0, 3), match='123'>, <re.Match object; span=(3, 6), match='456'>, <re.Match object; span=(6, 9), match='789'>]
```



### `fullmatch()`

如果整个字符串匹配正则表达式，就返回一个相应的匹配对象。如果没有匹配则返回`None`。 

```python
>>> re.fullmatch(r'\d{3,5}', '123456789')
>>> re.fullmatch(r'\d{3,10}', '123456789')
<re.Match object; span=(0, 9), match='123456789'>
```



### `match()`

如果字符串的一个前缀匹配正则表达式，就返回一个相应的匹配对象。如果没有匹配则返回`None`。 

```python
>>> re.match(r'\d{3,5}', '123456789')
<re.Match object; span=(0, 5), match='12345'>            # 匹配3~5个数字,最终匹配5个数字
>>> re.match(r'\d{3,5}', 'a123456789')                   # 前缀不匹配
>>>
>>> if re.match(r'^\d{3,4}\-\d{3,8}$', '0716-8834387'):  # 常用作判断条件
...     print('success')
... else:
...     print('failure')
... 
success
```



### `search()`

扫描整个字符串找到匹配正则表达式的第一个位置，并返回一个相应的匹配对象。如果没有匹配则返回`None`。 

```python
>>> re.search(r'\d{3,5}', '123456789')
<re.Match object; span=(0, 5), match='12345'>
>>> re.search(r'\d{3,5}', 'a123456789')
<re.Match object; span=(1, 6), match='12345'>
```



### `split()`

使用正则表达式划分字符串。

```python
>>> re.split(r'\W+', 'Words, words, words.')
['Words', 'words', 'words', '']
>>> re.split(r'(\W+)', 'Words, words, words.')    # 使用()会让正则表达式的匹配项也包含在列表里
['Words', ', ', 'words', ', ', 'words', '.', '']
```



### `sub()`

对字符串从左到右扫描，对所有字符不重复的正则表达式匹配项进行替换。

```python
>>> re.sub(r'\d{3}', '0', '123456789')
'000'
>>> re.sub(r'\d{3,5}', '0', '123456789')
'00'
```





# 练习

```python
>>> re.search('[\u4e00-\u9fff]', '中文')       # 匹配中文(中日韩统一表意文字)
<re.Match object; span=(0, 1), match='中'>

# 去掉
>>> 
'aa那就4哦撒01加上rw那就嗯'
```

vscode