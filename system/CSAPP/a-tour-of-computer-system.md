# 信息就是位+上下文

`hello`程序的生命周期从一个**源文件**开始，文件名是`hello.c`。源文件是由程序员通过编辑器创建并保存的文本文件，实际上是由值0和1组成的**位**序列。8个位被组织成一组，称为**字节**，每个字节表示程序中的某些文本字符。

大部分的现代计算机系统都是用ASCII标准表示文本字符，这种方式用一个唯一的单字节大小的整数值来表示字符。`hello.c`文件以字节序列的方式存储，每个字节都有一个整数值，对应于一个字符。像`hello.c`这样只由ASCII字符构成的文件称为**文本文件**，文本文件以外的其它文件称为**二进制文件**。

![Ascii Table](http://www.asciitable.com/index/asciifull.gif)

系统中所有的信息——包括磁盘文件，内存中的程序和用户数据，网络数据报都是由一串位序列表示的。区分不同数据对象的唯一方法是读取这些数据对象的**上下文**。





# 程序的编译

为了在系统上运行高级C语言程序，每条C语句都必须被其他程序转化为一系列的低级**机器语言**指令，然后这些指令按照一种称为**可执行目标文件**的格式打好包，并以二进制文件的形式存放起来。

在Unix系统上，从源文件到目标文件的转化是由**编译器驱动程序**完成的：

```
$ gcc -o hello hello.c
```

这里GCC编译器驱动程序读取源文件`hello.c`，并把它翻译成一个可执行目标文件`hello`。这个翻译过程可分为四个阶段完成，如图所示，执行这四个阶段的程序（**预处理器**，**编译器**，**汇编器**，**链接器**）共同构成了**编译系统（compilation system）**。



![](https://raw.githubusercontent.com/xyxxxxx/image/master/jgmefiloj356ykl357y35.PNG)

## 预处理阶段

预处理器（cpp）根据以字符#开头的命令，修改原始的C程序



## 编译阶段

编译器（ccl）将文本文件`hello.i`翻译成文本文件`hello.s`，它包含一个**汇编程序语言**。汇编语言为不同的高级语言的不同编译器提供了通用的输出语言。



## 汇编阶段

汇编器（as）将`hello.s`翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式。得到的`hello.o`是一个二进制文件。



## 链接阶段

`hello`程序调用了`printf`函数，它是C**标准库**中的一个函数。`printf`函数存在于一个名为`printf.o`的单独的预编译好了的目标文件中，这个文件必须合并到`hello.o`程序中。链接器（ld）负责处理这种合并。得到的`hello`文件是一个可执行目标文件（简称**可执行文件**），可以被加载到内存中由系统执行。





# 处理器读并解释存储在内存中的指令

## shell

shell是一个命令行解释器，用于执行一个命令。如果该命令的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，于是加载并运行这个文件。



## 系统的硬件组成

![](https://raw.githubusercontent.com/xyxxxxx/image/master/sdkop24j6kiho3hj4y.PNG)



### 总线

**总线**是贯穿整个系统的一组电子管道，它负责在各个部件之间传递信息字节。通常总线被设计成传送定长的字节块，即**字（word）**。字中的字节数（即**字长**）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器的字长或者是4个字节（32位），或者是8个字节（64位）。



### I/O设备

I/O设备是系统与外部世界的联系通道。这里的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，用于长期存储数据和程序的磁盘驱动器。

每个I/O设备都通过一个**控制器**或**适配器**与I/O总线相连。控制器和适配器之间的区别在于它们的封装方式：控制器是I/O设备本身或者系统的**主板**上的芯片组，而适配器是一块插在主板插槽上的卡。



### 主存

**主存**是一个临时存储设备，在CPU执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器（DRAM）**芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。



### CPU

**中央处理单元**（CPU），简称处理器，是执行存储在主存中指令的引擎。CPU的核心是一个大小为一个字的存储设备（即**寄存器**），称为**程序计数器（PC）**。在任何时刻，PC都指向主存中的某条机器语言指令。

CPU一直不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。CPU看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由**指令集架构**决定的。在这个模型中，指令按照严格的顺序执行，执行一条指令包含执行一系列的步骤。CPU从程序处理器指向的内存储读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令。

CPU的简单操作围绕着主存、**寄存器文件**（register file）和**算术逻辑单元**（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALI计算新的数据和地址值。以下是一些简单操作的例子：

+ **加载**：从主存复制一个字节或者一个字到寄存器，覆盖寄存器原来的内容
+ **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，覆盖该位置原来的内容
+ **操作**：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，覆盖该位置原来的内容
+ **跳转**：从指令本身中抽取一个字，将这个字复制到PC中，覆盖PC中原来的值

需要将处理器的指令集架构和处理器的**微体系结构**区分开来：指令集架构描述的是每条机器代码指令的效果，而微体系结构描述的是处理器的实际实现。



## 运行`hello`程序

初始时shell程序等待我们输入一个命令，当我们在键盘上输入字符串`./hello`后，shell程序将字符逐一读入寄存器，再把它存放到内存中。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/skvgop3yjkio3557jykiop35gy.PNG)

当我们再键盘上敲回车时，shell程序知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的`hello`文件，这些指令将`hello`目标文件中的代码和数据从磁盘复制到主存。利用**直接存储器存取（DMA）**技术，数据可以不通过处理器而直接从磁盘到达主存。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/asdfj8io24thjiog25h3n.PNG)

一旦目标文件`hello`中的代码和数据被加载到主存，处理器就开始执行`hello`程序和`main`程序中的机器语言指令。这些指令将`“hello, world\n”`字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/xfjio24tjiogwrnjgrefgh.PNG)



## 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量时间把信息从一个地方移动到另一个地方。这些复制就是开销，减慢了程序真正的工作。

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低俗设备。针对这种CPU与主存之间的差异，系统设计者采用了更小更快的存储设备，称为**高速缓存存储器（cache memory，简称cache或高速缓存）**，作为暂时的集结区域，存放处理器近期可能需要的信息。位于处理器芯片上的**L1高速缓存**的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的**L2高速缓存**通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是仍然比访问主存的时间快5\~10倍。L1和L2高速缓存是一种叫做**静态随机访问存储器（SRAM）**的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存。

高速缓存利用了**局部性原理**，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/dfsj8ui356u8oy356j3hy.PNG)

应用程序员能够利用高速缓存将程序的性能提高一个数量级。



## 存储设备形成层次结构

在处理器和一个较大较慢的设备（主存）之间插入一个更小更快的存储设备（高速缓存）的想法已经成为一个普遍的观念。实际上每个计算机系统的存储设备都被组织成了一个**存储器层次结构**。在这个层次结构中，从上到小，设备的访问速度越来越慢，容量越来越大，每字节的造价越来越便宜。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/fgjio2345tjiowgrjiorwg.PNG)

存储器层次结构的主要思想是上一层的存储器作为低一层的存储器的高速缓存。



## 操作系统管理硬件

当shell加载和运行`hello`程序，以及`hello`程序输出自己的消息时，shell和`hello`程序都没有直接访问键盘、显示器、磁盘或主存，取而代之的是，它们依靠**操作系统**提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（**进程**，**虚拟内存**和**文件**）来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对CPU、主存和I/O设备的抽象表示。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/xcvjioj24tiojngsfviokgfh.PNG)

### 进程