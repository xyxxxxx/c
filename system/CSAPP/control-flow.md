假设程序计数器的一个值的序列：
$$
a_o,a_1,\cdots,a_{n-1}
$$
其中$$a_k$$是某个相应的指令$$I_k$$的地址。每次从$$a_k$$到$$a_{k+1}$$的过渡称为**控制转移（control transfer）**。这样的控制转移序列叫做处理器的**控制流（control flow）**。

最简单的控制流是一个平滑的序列，其中每个$$I_k$$和$$I_{k+1}$$在内存中都是相邻的。而控制流的突变（即$$I_k$$与$$I_{k+1}$$在不相邻）通常是由诸如跳转、调用和返回这样一些指令造成的。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须存放在内存中；程序向磁盘请求数据，然后休眠，直到被通知数据已就绪；子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为**异常控制流（Exception Control Flow, ECF）**。异常控制流发生在计算机系统的各个层次：在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程；在应用层，一个进程可以发送**信号（signal）**到另一个进程，而接收者将控制突然转移到它的一个信号处理程序。程序可以通过回避通常的栈规则，并执行到其它函数中任意位置的非本地跳转来对错误做出反应。

作为程序员，理解ECF很重要，原因如下：

+ 理解ECF将帮助理解重要的系统概念。ECF是操作系统用来实现I/O，进程和虚拟内存的基本机制。
+ 理解ECF将帮助理解应用程序如何与操作系统交互。ECF通过使用一个称为**陷阱（trap）**或者**系统调用（system call）**的ECF形式，向操作系统请求服务，例如向磁盘写数据，从网络读取数据，创建一个新进程，以及终止当前进程等，都是通过应用程序调用系统调用来实现的。
+ 理解ECF将帮助编写应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其它进程系统中的异常事件，以及检测和响应这些事件。
+ 理解ECF将帮助理解并发。ECF是计算机系统中实现并发的基本机制。运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，中断应用程序执行的信号处理程序。



# 异常

**异常（exception）**是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常是控制流中的突变，用于响应处理器中的某些变化。

图

图中，当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令$$I_{curr}$$。在处理器中，状态被编码为不同的位和信号，状态的变化称为**事件（event）**。事件可能和当前指令的执行直接相关，例如发生虚拟内存缺页，算术溢出，除以零，也可能和当前指令的执行没有关系，例如一个系统定时器产生信号或者一个I/O请求完成。

任何情况下，当处理器检测到事件发生时，它就会通过一张叫做**异常表（exception table）**的跳转表，进行一个间接过程调用（异常调用）到一个专门设计用来处理这类事件的操作系统子程序（**异常处理程序（exception handler）**）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况之一：

1. 处理程序将控制返回给当前指令$$I_{curr}$$
2. 处理程序将控制返回给下一条指令$$I_{next}$$
3. 处理程序终止被中断的程序



## 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的**异常号（exception number）**，其中一些号码由处理器的设计者分配，而其它号码由操作系统内核的设计者分配。前者的示例包括除以零，缺页，内存访问违例，断点以及算术运算溢出，后者的示例包括系统调用和来自外部I/O设备的信号。

在系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表，使得表目k包含异常k的处理程序的地址，如图所示异常表的格式。

图

当执行程序时，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。如图展示了处理器如何使用异常表生成异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个称为**异常表基址寄存器（exception table base register）**的特殊寄存器里。

图

异常类似于过程调用，但是有一些差异：

+ 过程调用时，在跳转到处理器将返回地址压入栈中。然而，根据异常的类型，返回地址是当前指令或者下一条指令
+ 如果控制





# 进程控制

## 获取进程ID



## 创建和终止进程



## 回收子进程

当一个进程因为某种原因终止时，内核并不是立即将其从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程**回收（reaped）**。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从这时开始该进程就不再存在了。一个终止了但还未被回收的进程称为**僵死进程（zombie）**，僵死进程仍然占用系统的内存资源。

`init`进程的PID为1，是在系统启动时由内核创建的，是所有进程的祖先。如果一个父进程先于它的子进程终止，内核会安排`init`进程成为它的孤儿进程的养父，并在它们终止时进行回收。长时间运行的程序，例如shell或服务器，应该总是回收它们的僵死子进程。

进程可以调用`waitpid`函数来等待它的子进程终止：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
    //return PID of child process if success, 0 if WNOHANG, -1 if other err
```

默认情况下，即`options=0`时，`waitpid`挂起调用进程的执行，直到它的**等待集合（wait set）**中的某一个子进程终止。如果等待集合中的一个进程在调用之前就已经终止了，那么`waitpid`就立即返回。这种情况中`waitpid`返回导致其返回的已终止子进程的PID。此时已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。

**等待集合**

等待集合由参数`pid`确定：

+ 如果`pid > 0`，那么等待集合就是PID为`pid`的指定子进程
+ 如果`pid = -1`，那么等待集合就是父进程的所有子进程

**修改默认行为**

可以修改`options`为常量`WNOHANG`，`WUNTRACED`，`WCONTINUED`的各种组合来修改默认行为：

+ `WNOHANG` 如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回0）。在等待子进程终止的同时，如果还想做些有用的工作，可以使用这个选项。
+ `WUNTRACED` 挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回导致返回的已终止或被停止的子进程的PID。这个选项可以用于检查被停止的子进程。
+ `WCONTINUED` 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。

**检查已回收子进程的退出状态**

如果`statusp`参数是非空的，那么`waitpid`就会在`statusp`指向的位置写入关于导致返回的子进程的状态信息。`wait.h`头文件定义了几个宏用于解释`status`参数：

+ `WIFEXITED(status)`：如果子进程通过调用`exit`或者返回而正常终止，则返回真
+ `WEXITSTATUS(status)`：返回一个正常终止的子进程的退出状态
+ `WIFSIGNALED(status)`：如果子进程是因为一个未被捕获的信号终止的，则返回真
+ `WTERMSIG(status)`：返回导致子进程终止的信号的编号
+ `WIFSTOPPED(status)`：如果引起返回的子进程当前是停止的，则返回真
+ `WSTOPSIG(status)`：返回引起子进程停止的信号的编号
+ `WIFCONTINUED(status)`：如果子进程收到SIGCONT信号重新启动，则返回真

**错误条件**

如果调用进程没有子进程，那么`waitpid`返回-1，并且设置`errno`为ECHILD；如果`waitpid`被一个信号中断，那么它返回-1，并设置`errno`为EINTR。

**`wait`函数**

`wait`函数是`waitpid`函数的简单版本：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statusp);
    // equals waitpid(-1, &status, 0)
```

**`waitpid`实例**

第一个程序使用`waitpid`，不按照特定的顺序等待它的所有N个子进程终止。

代码

第11行，父进程创建N个子进程。第12行，每个子进程以唯一的退出状态退出。第15行，父进程用`waitpid`作为`while`循环的测试条件，等待它所有的子进程终止；当回收了所有的子进程之后，再调用`waitpid`就返回-1，并且设置`errno`为ECHILD。第16，18行，检查子进程的退出状态。第24行，检查`waitpid`函数是否正常终止。

注意程序不会按照特定的顺序回收子进程，这样的并发是非确定性行为。也可以按照顺序回收子进程。



## 休眠进程

`sleep`函数将一个进程挂起一段指定的时间。

```c
#include <unistd.h>
unsigned int sleep(unsigned int secs);
	// return secs remained to be sleep
```

如果进程休眠了指定的时间，那么`sleep`返回0；如果`sleep`函数被一个信号中断而返回，那么返回剩余要休眠的秒数。

`pause`函数让调用函数休眠，直到该进程收到一个信号。

```c
#include <unistd.h>
int pause(void);
    // return -1
```



## 加载并运行程序

`execve`函数在当前进程的上下文中加载并运行一个新程序。





# 信号

本节将讨论一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其它进程。

一个信号就是一条消息，它通知进程系统中发生了一个某种类型的事件。如图所示Linux系统上支持的30种不同类型的信号。

图

每种信号都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下对于用户进程不可见，信号提供了一种机制，能够通知用户进程发生了这些异常：例如如果一个进程试图除以零，那么内核就发送给它一个SIGFPE信号（8）；如果一个进程执行一条非法指令，那么内核就发送给它一个SIGILL信号（4）；如果进程进行非法内存引用，内核就发送给它一个SIGSEGV信号（11）。其它信号对应于内核或者其它用户进程中较高层的软件事件：例如进程在前台运行时，键入Ctrl+C，内核就会发送一个SIGINT信号（2）给这个前台进程组中的每个进程；一个进程可以通过向另一个进程发送SIGKILL信号（9）强制终止它；子进程终止或停止时，内核会发送一个SIGCHLD信号（17）给父进程。



## 信号术语

传送一个信号到目的进程由两个不同的步骤组成：

+ 发送信号



## 发送信号



## 接收信号



## 编写信号处理程序

信号处理是Linux系统编程中最棘手的一个问题





**安全的信号处理**

信号处理程序很麻烦是因为它们和主程序以及其它信号处理程序并发地运行。如果处理程序和主程序并发地访问同一个全局数据结构，那么结果就会不可预知，而且经常是致命的。这里提供一些保守的编写处理程序的原则，意在使得这些处理程序能够安全地并发运行：

1. <u>处理程序要尽可能简单</u> 例如处理程序只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志。
2. <u>在处理程序中只调用异步信号安全的函数</u> **异步信号安全**的函数能够被信号处理程序安全地调用，原因或者是它是可重入的，或者是它不能被信号处理程序中断。如图列出了Linux保证安全的函数。
3. <u>保存和恢复`errno`</u>



**正确的信号处理**

未处理的信号是不排队的，因为`pending`位向量中每种类型的信号只对应一位。如果存在一个未处理的信号就表明至少有一个信号到达了。