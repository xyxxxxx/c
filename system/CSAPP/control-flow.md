假设程序计数器的一个值的序列：
$$
a_o,a_1,\cdots,a_{n-1}
$$
其中$$a_k$$是某个相应的指令$$I_k$$的地址。每次从$$a_k$$到$$a_{k+1}$$的过渡称为**控制转移（control transfer）**。这样的控制转移序列叫做处理器的**控制流（control flow）**。

最简单的控制流是一个平滑的序列，其中每个$$I_k$$和$$I_{k+1}$$在内存中都是相邻的。而控制流的突变（即$$I_k$$与$$I_{k+1}$$在不相邻）通常是由诸如跳转、调用和返回这样一些指令造成的。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须存放在内存中；程序向磁盘请求数据，然后休眠，直到被通知数据已就绪；子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为**异常控制流（Exception Control Flow, ECF）**。异常控制流发生在计算机系统的各个层次：在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程；在应用层，一个进程可以发送**信号（signal）**到另一个进程，而接收者将控制突然转移到它的一个信号处理程序。程序可以通过回避通常的栈规则，并执行到其它函数中任意位置的非本地跳转来对错误做出反应。

作为程序员，理解ECF很重要，原因如下：

+ 理解ECF将帮助理解重要的系统概念。ECF是操作系统用来实现I/O，进程和虚拟内存的基本机制。
+ 理解ECF将帮助理解应用程序如何与操作系统交互。ECF通过使用一个称为**陷阱（trap）**或者**系统调用（system call）**的ECF形式，向操作系统请求服务，例如向磁盘写数据，从网络读取数据，创建一个新进程，以及终止当前进程等，都是通过应用程序调用系统调用来实现的。
+ 理解ECF将帮助编写应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其它进程系统中的异常事件，以及检测和响应这些事件。
+ 理解ECF将帮助理解并发。ECF是计算机系统中实现并发的基本机制。运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，中断应用程序执行的信号处理程序。



# 异常

**异常（exception）**是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常是控制流中的突变，用于响应处理器中的某些变化。

图

图中，当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令$$I_{curr}$$。在处理器中，状态被编码为不同的位和信号，状态的变化称为**事件（event）**。事件可能和当前指令的执行直接相关，例如发生虚拟内存缺页，算术溢出，除以零，也可能和当前指令的执行没有关系，例如一个系统定时器产生信号或者一个I/O请求完成。

任何情况下，当处理器检测到事件发生时，它就会通过一张叫做**异常表（exception table）**的跳转表，进行一个间接过程调用（异常调用）到一个专门设计用来处理这类事件的操作系统子程序（**异常处理程序（exception handler）**）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况之一：

1. 处理程序将控制返回给当前指令$$I_{curr}$$
2. 处理程序将控制返回给下一条指令$$I_{next}$$
3. 处理程序终止被中断的程序



## 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的**异常号（exception number）**，其中一些号码由处理器的设计者分配，而其它号码由操作系统内核的设计者分配。前者的示例包括除以零，缺页，内存访问违例，断点以及算术运算溢出，后者的示例包括系统调用和来自外部I/O设备的信号。

在系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表，使得表目k包含异常k的处理程序的地址，如图所示异常表的格式。

图

当执行程序时，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。如图展示了处理器如何使用异常表生成异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个称为**异常表基址寄存器（exception table base register）**的特殊寄存器里。

图

异常类似于过程调用，但是有一些差异：

+ 过程调用时，在跳转到处理器将返回地址压入栈中。然而，根据异常的类型，返回地址是当前指令或者下一条指令
+ 如果控制