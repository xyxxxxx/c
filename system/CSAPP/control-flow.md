假设程序计数器的一个值的序列：
$$
a_o,a_1,\cdots,a_{n-1}
$$
其中$$a_k$$是某个相应的指令$$I_k$$的地址。每次从$$a_k$$到$$a_{k+1}$$的过渡称为**控制转移（control transfer）**。这样的控制转移序列叫做处理器的**控制流（control flow）**。

最简单的控制流是一个平滑的序列，其中每个$$I_k$$和$$I_{k+1}$$在内存中都是相邻的。而控制流的突变（即$$I_k$$与$$I_{k+1}$$在不相邻）通常是由诸如跳转、调用和返回这样一些指令造成的。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须存放在内存中；程序向磁盘请求数据，然后休眠，直到被通知数据已就绪；子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为**异常控制流（Exception Control Flow, ECF）**。异常控制流发生在计算机系统的各个层次：在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程；在应用层，一个进程可以发送**信号（signal）**到另一个进程，而接收者将控制突然转移到它的一个信号处理程序。程序可以通过回避通常的栈规则，并执行到其它函数中任意位置的非本地跳转来对错误做出反应。

###### 作为程序员，理解ECF很重要，原因如下：

+ 理解ECF将帮助理解重要的系统概念。ECF是操作系统用来实现I/O，进程和虚拟内存的基本机制。
+ 理解ECF将帮助理解应用程序如何与操作系统交互。ECF通过使用一个称为**陷阱（trap）**或者**系统调用（system call）**的ECF形式，向操作系统请求服务，例如向磁盘写数据，从网络读取数据，创建一个新进程，以及终止当前进程等，都是通过应用程序调用系统调用来实现的。
+ 理解ECF将帮助编写应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其它进程系统中的异常事件，以及检测和响应这些事件。
+ 理解ECF将帮助理解并发。ECF是计算机系统中实现并发的基本机制。运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，中断应用程序执行的信号处理程序。



# 异常

**异常（exception）**是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常是控制流中的突变，用于响应处理器中的某些变化。

图8-1

图中，当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令$$I_{curr}$$。在处理器中，状态被编码为不同的位和信号，状态的变化称为**事件（event）**。事件可能和当前指令的执行直接相关，例如发生虚拟内存缺页，算术溢出，除以零，也可能和当前指令的执行没有关系，例如一个系统定时器产生信号或者一个I/O请求完成。

任何情况下，当处理器检测到事件发生时，它就会通过一张叫做**异常表（exception table）**的跳转表，进行一个间接过程调用（异常调用）到一个专门设计用来处理这类事件的操作系统子程序（**异常处理程序（exception handler）**）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况之一：

1. 处理程序将控制返回给当前指令$$I_{curr}$$
2. 处理程序将控制返回给下一条指令$$I_{next}$$
3. 处理程序终止被中断的程序



## 异常处理

系统中每种可能的的异常类型都分配了一个唯一的非负整数的**异常号（exception number）**，其中一些号码由处理器的设计者分配，而其它号码由操作系统内核的设计者分配。前者的示例包括除以零，缺页，内存访问违例，断点以及算术运算溢出，后者的示例包括系统调用和来自外部I/O设备的信号。

在系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表，使得表目k包含异常k的处理程序的地址，如图所示异常表的格式。

图8-2

<u>当执行程序时，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序</u>。如图展示了处理器如何使用异常表生成异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个称为**异常表基址寄存器（exception table base register）**的特殊寄存器里。

图8-3

异常类似于过程调用，但是有一些差异：

+ 过程调用时，在跳转到处理器将返回地址压入栈中。然而，根据异常的类型，返回地址是当前指令或者下一条指令。
+ 处理器会把一些额外的处理器状态压栈，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64系统会将包含当前条件码的EFLAGS寄存器和其它内容压栈。
+ 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。
+ 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。



## 异常的类别

异常可以分为四类：**中断（interrupt）**、**陷阱（trap）**、**故障（fault）**和**终止（abort）**。下图对这些类别的属性做了小结。

图8-4



**中断**是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断的异常处理程序常常称为**中断处理程序（interrupt handler）**。

下图概述了一个中断的处理。I/O设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发出信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

图8-5

在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，于是从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令。结果就是程序继续执行，就好像没有发生过中断一样。

中断之外的异常类型是同步发生的，是执行当前指令的结果。这类引起异常的指令称为**故障指令（faulting instruction）**。



**陷阱**是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核中间提供一个像过程一样的接口，称为**系统调用**。

用户程序经常需要向内核请求服务，比如读一个文件（`read`）、创建一个新的进程（`fork`）、加载一个新的程序（`execve`），或者终止当前进程（`exit`）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的`syscall n`指令，当用户程序想要请求服务n时，可以执行这条指令。执行`syscall` 指令会导致一个到异常处理程序的陷阱这个处理程序解析参数，并调用适当的内核程序。下图概述了一个系统调用的处理。

图8-6

从程序员的角度来看，系统调用和函数调用是一样的。然而它们的实现非常不同。<u>普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈</u>。<u>系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈</u>。



**故障**由错误情况引起，它可能能够被故障处理程序修正。<u>当故障发生时，处理器将控制程序转移给故障处理程序，如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它</u>。否则处理程序返回到内核中的`abort`例程，`abort`例程会终止引起故障的应用程序。下图概述了一个故障的处理。

图8-7

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。



**终止**是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被破坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如下图所示，处理程序将控制返回给一个`abort`例程，该例程会终止这个应用程序。

图8-8



## Linux/x86-64系统中的异常

让我们来看x86-64系统定义的一些异常。有高达256种不同的异常类型。0~31对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的；32~255对应的是操作系统定义的中断和陷阱。下图展示了一些示例：

图8-9

**故障和终止**

+ 除法错误：当应用试图除以零，或者一个除法指令的结果对于目标操作数太大的时候（除以近似零），就会发生除法错误（异常0）。Unix不会试图从除法错误中恢复，而是选择终止程序。Linux shell通常把除法错误报告为浮点异常（floating exception）。
+ 一般保护故障：许多原因都会导致一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复一般保护故障。Linux shell通常把一般保护错误报告为段故障（segmentation fault）。
+ 缺页：缺页（异常14）是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。
+ 机器检查：机器检查（异常18）是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。

**系统调用**

下图给出了一些常见的Linux系统调用，其中每个系统调用都有一个唯一的整数编号，对应于一个到内核中跳转表的偏移量。

C程序用`syscall`函数可以直接调用任何系统调用，但实际上没有必要这么做。对于大多数系统调用，标准C库提供了一组方便的包装函数，这些包装函数将参数打包在一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。本书中，我们将系统调用和它们的包装函数统称为<u>系统级函数</u>。













# 进程

**进程（process）**是计算机科学中最深刻、最成功的概念之一。在现代操作系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一程序一样。<u>我们的程序好像是独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行我们程序中的指令；程序中的代码和数据好像是系统内存中唯一的对象</u>。这些假象都是通过进程的概念提供给我们的。

进程的经典定义就是一个<u>正在执行的程序实例</u>。系统中的每个程序都运行在某个进程的**上下文（context）**中。上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器、程序计数器、环境变量以及打开文件描述符的集合。

每次用户向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其它应用程序。

操作系统实现进程的细节请参考《现代操作系统》，这里仅讨论进程提供给应用程序的关键抽象：

+ 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器
+ 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统



## 逻辑控制流

即使在系统中通常有许多其它程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果用调试器单步执行程序，我们会看到一系列程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件这种的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值序列称为**逻辑控制流**，或简称**逻辑流**。

考虑一个运行着三个进程的系统，如下图所示，处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。

图8-12

在这个例子中，三个逻辑流的执行是交错的：进程A运行了一会儿，然后进程B开始运行直到完成，然后进程C运行了一会儿，接着进程A运行直到完成，最后进程C运行直到完成。

上图的关键点在于进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被**抢占（preempted）**（暂时挂起），轮到其它进程。



## 并发流

计算机系统中的逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。

一个逻辑流的执行在时间上与另一个流重叠，称为**并发流（concurrent flow）**，这两个流被称为<u>并发地运行</u>。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。例如图8-12中进程A和B、A和C并发地运行，而B和C没有并发地运行。

多个流并发地执行的一般现象称为**并发（concurrency）**；一个进程和其它进程轮流运行的概念称为**多任务（multitasking）**；一个进程执行它的控制流的一部分的每一时间段称为**时间片（time slice）**。因此多任务也称为**时间分片（time slicing）**。

注意并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，<u>即使它们是运行在同一个处理器上</u>。并行流是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们就称它们为**并行流（parallel flow）**，它们**并行地运行（running in parallel）**。



## 私有地址空间

进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台$$n$$位地址的机器上，<u>地址空间</u>是$$2^n$$个地址的集合：$$0, 1, …,2^n-1$$。进程为每个程序提供它自己的<u>私有地址空间</u>。一般而言，这个空间中的某个地址相关联的内存字节是不能被其它进程读或者写的，从这个意义上说，这个地址空间是私有的。

尽管每个私有地址空间相关联的内存内容一般是不同的，但是都有相同的通用结构。例如下图展示了一个x86-64 Linux进程的地址空间的组织结构。

图8-13

地址空间的底部保留给用户程序，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000开始。地址空间顶部保留给内核，包含内核在代表进程执行指令时（例如当应用程序执行系统调用时）使用的代码、数据、栈。



## 用户模式和系统模式

处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常用某个控制寄存器中的一个**模式位（mode bit）**来提供这种功能，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在**内核模式**中（也称为**超级用户模式**）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。

没有设置模式位时，进程就运行在**用户模式**中。用户模式中的进程不允许执行**特权指令（privileged instruction）**，比如停止处理器，改变模式位，或者发起一个I/O操作，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。

运行应用程序代码的进程初始时处于用户模式，进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。

Linux提供了一种聪明的机制，叫做`/proc`文件系统，它允许用户模式进程访问内核数据结构的内容。`/proc`文件系统将许多内核数据结构的内容输出位一个用户程序可以读的文本文件的层次结构。比如，你可以使用`/proc`文件系统找出一般的系统属性，比如CPU类型（`/proc/cpuinfo`），或者某个特定的进程使用的内存段（`/proc/<process-id>/maps`）。2.6版本的Linux内核引入`/sys`文件系统，它输出关于系统总线和设备的额外的底层信息。



## 上下文切换

操作系统内核使用一种称为**上下文切换（context switch）**的较高层形式的异常控制流来实现多任务。上下文切换机制建立在异常部分讨论过的较底层异常机制之上。

内核为每个进程维持一个**上下文（context）**。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就称为**调度（scheduling）**，有内核中称为**调度器（scheduler）**的代码处理。当内核选择一个新的进程运行后（称内核调度了这个进程），内核就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程中，上下文切换

+ 保存当前进程的上下文
+ 恢复某个先前被抢占的进程被保存的上下文
+ 将控制传递给这个被恢复的进程

当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个`read`系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。

下图展示了一对进程A和B之间上下文切换的示例。

图8-14

在这个例子中，进程A初始运行在用户模式中，直到它通过执行系统调用`read`陷入到内核。内核的陷阱处理程序请求来自磁盘控制器的DMA传输，并且安排在磁盘控制器完成磁盘到内存的数据传输后，磁盘中断处理器。

磁盘取数据要用一段相对较长的时间（大约几十毫秒），所以内核执行从进程A到进程B的上下文切换，而不是在这个间歇时间内等待。注意在切换之前，（内核代表）进程A在用户模式下执行指令；在切换过程中，内核代表进程A在内核模式下执行指令，然后在某一时刻切换为，代表进程B在内核模式下执行指令；切换之后，（内核代表）进程B在用户模式下执行指令。

随后，进程B在用户模式下运行一会，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用`read`之后的那条指令。进程A继续运行，直到下一次异常发生。





# 进程控制

## 获取进程ID



## 创建和终止进程



## 回收子进程

当一个进程因为某种原因终止时，内核并不是立即将其从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程**回收（reaped）**。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从这时开始该进程就不再存在了。一个终止了但还未被回收的进程称为**僵死进程（zombie）**，僵死进程仍然占用系统的内存资源。

`init`进程的PID为1，是在系统启动时由内核创建的，是所有进程的祖先。如果一个父进程先于它的子进程终止，内核会安排`init`进程成为它的孤儿进程的养父，并在它们终止时进行回收。长时间运行的程序，例如shell或服务器，应该总是回收它们的僵死子进程。

进程可以调用`waitpid`函数来等待它的子进程终止：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
    //return PID of child process if success, 0 if WNOHANG, -1 if other err
```

默认情况下，即`options=0`时，`waitpid`挂起调用进程的执行，直到它的**等待集合（wait set）**中的某一个子进程终止。如果等待集合中的一个进程在调用之前就已经终止了，那么`waitpid`就立即返回。这种情况中`waitpid`返回导致其返回的已终止子进程的PID。此时已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。

**等待集合**

等待集合由参数`pid`确定：

+ 如果`pid > 0`，那么等待集合就是PID为`pid`的指定子进程
+ 如果`pid = -1`，那么等待集合就是父进程的所有子进程

**修改默认行为**

可以修改`options`为常量`WNOHANG`，`WUNTRACED`，`WCONTINUED`的各种组合来修改默认行为：

+ `WNOHANG` 如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回0）。在等待子进程终止的同时，如果还想做些有用的工作，可以使用这个选项。
+ `WUNTRACED` 挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回导致返回的已终止或被停止的子进程的PID。这个选项可以用于检查被停止的子进程。
+ `WCONTINUED` 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。

**检查已回收子进程的退出状态**

如果`statusp`参数是非空的，那么`waitpid`就会在`statusp`指向的位置写入关于导致返回的子进程的状态信息。`wait.h`头文件定义了几个宏用于解释`status`参数：

+ `WIFEXITED(status)`：如果子进程通过调用`exit`或者返回而正常终止，则返回真
+ `WEXITSTATUS(status)`：返回一个正常终止的子进程的退出状态
+ `WIFSIGNALED(status)`：如果子进程是因为一个未被捕获的信号终止的，则返回真
+ `WTERMSIG(status)`：返回导致子进程终止的信号的编号
+ `WIFSTOPPED(status)`：如果引起返回的子进程当前是停止的，则返回真
+ `WSTOPSIG(status)`：返回引起子进程停止的信号的编号
+ `WIFCONTINUED(status)`：如果子进程收到SIGCONT信号重新启动，则返回真

**错误条件**

如果调用进程没有子进程，那么`waitpid`返回-1，并且设置`errno`为ECHILD；如果`waitpid`被一个信号中断，那么它返回-1，并设置`errno`为EINTR。

**`wait`函数**

`wait`函数是`waitpid`函数的简单版本：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statusp);
    // equals waitpid(-1, &status, 0)
```

**`waitpid`实例**

第一个程序使用`waitpid`，不按照特定的顺序等待它的所有N个子进程终止。

代码

第11行，父进程创建N个子进程。第12行，每个子进程以唯一的退出状态退出。第15行，父进程用`waitpid`作为`while`循环的测试条件，等待它所有的子进程终止；当回收了所有的子进程之后，再调用`waitpid`就返回-1，并且设置`errno`为ECHILD。第16，18行，检查子进程的退出状态。第24行，检查`waitpid`函数是否正常终止。

注意程序不会按照特定的顺序回收子进程，这样的并发是非确定性行为。也可以按照顺序回收子进程。



## 休眠进程

`sleep`函数将一个进程挂起一段指定的时间。

```c
#include <unistd.h>
unsigned int sleep(unsigned int secs);
	// return secs remained to be sleep
```

如果进程休眠了指定的时间，那么`sleep`返回0；如果`sleep`函数被一个信号中断而返回，那么返回剩余要休眠的秒数。

`pause`函数让调用函数休眠，直到该进程收到一个信号。

```c
#include <unistd.h>
int pause(void);
    // return -1
```



## 加载并运行程序

`execve`函数在当前进程的上下文中加载并运行一个新程序。





# 信号

本节将讨论一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其它进程。

一个信号就是一条消息，它通知进程系统中发生了一个某种类型的事件。如图所示Linux系统上支持的30种不同类型的信号。

图

每种信号都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下对于用户进程不可见，信号提供了一种机制，能够通知用户进程发生了这些异常：例如如果一个进程试图除以零，那么内核就发送给它一个SIGFPE信号（8）；如果一个进程执行一条非法指令，那么内核就发送给它一个SIGILL信号（4）；如果进程进行非法内存引用，内核就发送给它一个SIGSEGV信号（11）。其它信号对应于内核或者其它用户进程中较高层的软件事件：例如进程在前台运行时，键入Ctrl+C，内核就会发送一个SIGINT信号（2）给这个前台进程组中的每个进程；一个进程可以通过向另一个进程发送SIGKILL信号（9）强制终止它；子进程终止或停止时，内核会发送一个SIGCHLD信号（17）给父进程。



## 信号术语

传送一个信号到目的进程由两个不同的步骤组成：

+ 发送信号



## 发送信号



## 接收信号



## 编写信号处理程序

信号处理是Linux系统编程中最棘手的一个问题





**安全的信号处理**

信号处理程序很麻烦是因为它们和主程序以及其它信号处理程序并发地运行。如果处理程序和主程序并发地访问同一个全局数据结构，那么结果就会不可预知，而且经常是致命的。这里提供一些保守的编写处理程序的原则，意在使得这些处理程序能够安全地并发运行：

1. <u>处理程序要尽可能简单</u> 例如处理程序只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志。
2. <u>在处理程序中只调用异步信号安全的函数</u> **异步信号安全**的函数能够被信号处理程序安全地调用，原因或者是它是可重入的，或者是它不能被信号处理程序中断。如图列出了Linux保证安全的函数。
3. <u>保存和恢复`errno`</u>



**正确的信号处理**

未处理的信号是不排队的，因为`pending`位向量中每种类型的信号只对应一位。如果存在一个未处理的信号就表明至少有一个信号到达了。