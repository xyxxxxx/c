计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以**汇编代码**的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

当我们用高级语言编程的时候，机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程时，程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关。

尽管如此，阅读和理解汇编代码仍然是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。也有些时候高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。

x86-64是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言历史悠久，起源于Intel公司1978年的第一个16位处理器，然后扩展到32位，64位。





# 历史观点

Intel处理器系列俗称x86，经历了一个长期的、不断进化的发展过程。

Intel处理器模型介绍略。

近年来许多公司生产出了与Intel处理器兼容的处理器，能够运行完全相同的机器级程序，其中领头的是AMD。





# 程序编码

假设一个
C程序有两个文件`p1.c`和`p2.c`，我们用Unix命令行编译这些代码：

```
$ gcc -)g -o p p1.c p2.c
```

命令`gcc`指的就是GCC C编译器，这是Linux上默认的编译器。编译选项`-Og`告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用更高级别优化（如`-O1`或`-O2`）产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解，但从得到的程序的性能考虑，更高级别的优化是更高的选择。



## 机器级代码

对于机器级编程来说，两种抽象十分重要。第一种是由**指令集体系结构**或**指令集架构（ISA，Instruction Set Architecture）**来定义机器级程序的格式和行为，它包括了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按照顺序执行的。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。第二种是机器级程序使用的内存地址是虚拟地址。

汇编代码表示非常接近于机器代码，与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始C代码的联系，是理解计算机如何执行程序的关键一步。

x86-64机器代码中，一些通常对C语言程序员隐藏的处理器状态都是可见的：

+ 程序计数器给出将要执行的下一条指令在内存中的地址
+ 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些存储器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其它的寄存器用来保存临时数据，例如过程的参数和局部变量，函数的返回值。
+ 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，例如用来实现`if`和`while`语句。
+ 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如x86-64的虚拟地址由64位的字来表示，在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$$2^{48}$$或64TB范围内的一个字节。

一条机器指令只执行一个非常基本的操作，例如将存放在寄存器中的两个数字相加，在存储器和寄存器之间传递数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现程序结构。



## 代码示例

假设我们编写了一个C语言代码文件`mstore.c`，包含如下的函数定义：

```c
long mult2(long, long);

void multstore(long x, long y, long *dest){
    long t = mult2(x, y);
    *dest = t;
}
```

使用`gcc -S mstore.c`产生汇编文件`mstore.s`，其中包括下面几行：

```
multstore:
	pushq   %rbx
	movq    %rdx, %rbx
	call    mult2
	movq    %rax, (%rbx)
	popq    %rbx
	ret
```

以上代码中每个缩进的行都对应于一条机器指令。

如果使用`gcc -c mstore.c`产生目标代码文件`mstore.o`。1368字节的该文件中有一段14字节的序列，其十六进制表示为：

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

这就是上面列出的汇编指令对应的机器代码（目标代码）。从中我们知道，机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

**反汇编器（disassembler）**程序可以根据机器代码产生一种类似汇编代码的格式，在Linux系统中使用`objdump -d mstore.o`反汇编得到如下结果：

```
0000000000000000 <multstore>:

0:   53                       push   %rbx
1:   48 89 d3                 mov    %rdx,%rbx
4:   e8 00 00 00 00           callq  9 <multstore+0x9>
9:   48 89 03                 mov    %rax,(%rbx)
c:   5b                       pop    %rbx
d:   c3                       retq
```

我们看到前面14字节的序列分成了若干组，每组都是一条指令，右边是等价的汇编语言。

其中一些关于机器代码和它的反汇编表示的特性值得注意：

+ x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需的字节数多。
+ 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一解码成机器指令，例如只有指令`push %rbx`是以字节值53开头的。
+ 反汇编器基于机器代码文件中的字节序列来确定汇编代码，它不需要访问程序的源代码或汇编代码，并且反汇编生成的汇编代码与GCC生成的汇编代码有些细微的差别

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个`main`函数。假设文件`main.c`如下：

```c
#include <stdio.h>

void multstore(long, long, long *)
    
int main() {
    long d;
    multstore(2,3,&d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

long mult2(long a, long b) {
    long s = a * b
    return s
}
```

使用`GCC -o prog main.c mstore.c`生成可执行文件`prog`，该文件大小为8655个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来和操作系统交互的代码。

如果使用`objdump -d prog`反汇编`prog`文件，反汇编器会抽取各种代码序列，包括下面这段：

```
0000000000400540 <multstore>:

400540:   53                       push   %rbx
400541:   48 89 d3                 mov    %rdx,%rbx
400544:   e8 00 00 00 00           callq  40058b <mult2>
400549:   48 89 03                 mov    %rax,(%rbx)
40054c:   5b                       pop    %rbx
40054d:   c3                       retq
40054e:   90                       nop
40054f:   90                       nop
```

这段代码与`mstore.o`反汇编产生的代码几乎一样，不同之处包括：左边列出的地址不同——链接器将这段代码的地址移到了一段不同的地址范围中；链接器填上了`callq`指令调用函数`mult2`需要使用的地址（链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置）；多了两行代码——这两条指令的作用是使函数代码变为16字节，使得就存储器性能而言，能更好地放置下一个代码块。



## 关于格式的注解

汇编文件`mstore.s`的完整内容如下：

```
    .file   "010-mstore.c"
    .text
    .globl  multstore
    .type   multstore, @function

multstore:
	pushq   %rbx
	movq    %rdx, %rbx
	call    mult2
	movq    %rax, (%rbx)
	popq    %rbx
	ret
	.size   multstore, .-multstore
	.ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
	.section        .note.GNU-stack,"",@progbits
```

所有以`.`开头的行都是直到汇编器和链接器工作的伪指令，我们通常忽略这些行。

为了更清楚地说明汇编代码，我们使用如图的格式表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。

图





# 数据格式

由于起初的体系结构为16位，Intel用“字（word）”表示16位数据类型，因此32位数据类型为“双字（double words）”，64位为“四字（quad words）”。如图所示
C语言基本数据类型对应的x86-64表示。

图

大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有4个变种：`movb`，`movw`，`movl`，`movq`。后缀`l`既表示4字节整数也表示8字节双精度浮点数，但这不会产生歧义，因为浮点数使用一组完全不同的指令和寄存器。





# 访问数据

一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。如图显示了这16个寄存器，它们的名字都以`%r`开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。

图

如图中嵌套的方框标明的，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置0。

如图右边的解释说明的，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针`%rsp`，用来指明运行时栈的结束位置。另外15个寄存器的用法更灵活，只有少量指令会使用某些特定的寄存器。



## 操作数指示符

大多数指令有一个或多个**操作数（operand）**，指示出执行一个操作要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出；结果可以存放在寄存器或内存中。因此各种不同的操作数的可能性分为三种类型：

1. **立即数（immediate）** 表示常数值。ATT汇编语言中，立即数的书写方式是`$`后面跟一个C语言表示的整数。不同的指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
2. **寄存器（register）** 表示某个寄存器的内容。`R[]`表示寄存器的值。
3. **内存** 根据计算出来的地址（称为有效地址）访问某个内存位置。`M[]`表示内存的值。

如图所示，有多种不同的寻址模式，允许不同形式的内存引用。最常用的是$$Imm(r_b,r_i,s)$$，这样的引用有四个组成部分：一个立即数偏移$$Imm$$，一个基址寄存器$$r_b$$，一个变址寄存器$$r_i$$和一个比例因子s，这里s必须是1，2，4或8。基址寄存器和变址寄存器都必须是64位寄存器。有效地址计算为$$Imm+R[r_b]+R[r]\cdot s$$。

图



## 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

我们把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只是操作数大小不同。

如图所示最简单形式的数据传送指令——MOV类，这些指令把数据从源位置复制到目的位置，不做任何变化。

图

源操作数指定的值是一个立即数，存储在寄存器中或者内存中；目的操作数指定一个位置，是一个寄存器或者内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置，将一个值从一个内存位置复制到另一个内存位置需要两条指令和一个寄存器。

下图记录了两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（寄存器或内存）复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，即复制源值的最高位。

图



## 数据传送示例

作为一个使用数据传送指令的代码示例，考虑如下的数据交换函数，既有C代码，又有GCC产生的汇编代码：

图

如图所示，函数`exchange`由三条指令实现：两个数据传送（`movq`），以及返回函数被调用点（`ret`）。当过程开始执行时，过程参数`xp`和`y`分别存储在寄存器`%rdi`和`%rsi`中，然后指令2从内存中读出`x`并存放到寄存器`%rax`中。稍后函数返回寄存器`%rax`的值，因而返回了`x`。指令3将`y`写入寄存器`$rdi`中`xp`指向的内存位置。

关于这段汇编代码有两点值得注意：首先C语言的指针其实就是地址，使用指针就是将地址存放在一个寄存器中，然后在内存引用中使用这个寄存器；其次像`x`这样的局部变量通常是保存在寄存器中而不是内存中，因为访问寄存器比访问内存要快得多。



## 压入和弹出栈数据

最后两个数据传送操作是将数据压入程序栈中，以及从程序栈中弹出数据。在x86-64中，程序栈存放在内存中某个区域，如图所示，栈向下增长，这样一来栈顶元素的地址是栈中所有元素地址中最低的。

图

因为栈和程序代码以及其它形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置，例如指令`movq 8(%rsp),%rdx`会将栈顶的第二个元素从栈中复制到寄存器`%rdx`。





# 算术和逻辑操作

如图所示x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

图



## 加载有效地址

**加载有效地址（load effective address）**指令`leaq`实际上是`movq`指令的变形。该指令并没有真正去引用内存，而只是将内存地址复制到寄存器。编译器经常发现`leaq`的一些灵活用法，根本就与有效地址计算无关，例如如果寄存器`%rdi`的值为`x`，寄存器`%rsi`的值为`y`，那么指令`leaq 7(%rdi,%rsi,4),%rax`将设置寄存器`%rax`的值为`5x+7`。



## 一元操作和二元操作

