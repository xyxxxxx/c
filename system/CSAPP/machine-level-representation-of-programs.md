计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以**汇编代码**的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

当我们用高级语言编程的时候，机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程时，程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关。

尽管如此，阅读和理解汇编代码仍然是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。也有些时候高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。

x86-64是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言历史悠久，起源于Intel公司1978年的第一个16位处理器，然后扩展到32位，64位。





# 历史观点

Intel处理器系列俗称x86，经历了一个长期的、不断进化的发展过程。

Intel处理器模型介绍略。

近年来许多公司生产出了与Intel处理器兼容的处理器，能够运行完全相同的机器级程序，其中领头的是AMD。





# 程序编码

假设一个C程序有两个文件`p1.c`和`p2.c`，我们用Unix命令行编译这些代码：

```
$ gcc -)g -o p p1.c p2.c
```

命令`gcc`指的就是GCC C编译器，这是Linux上默认的编译器。编译选项`-Og`告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用更高级别优化（如`-O1`或`-O2`）产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解，但从得到的程序的性能考虑，更高级别的优化是更高的选择。



## 机器级代码

对于机器级编程来说，两种抽象十分重要。第一种是由**指令集体系结构**或**指令集架构（ISA，Instruction Set Architecture）**来定义机器级程序的格式和行为，它包括了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按照顺序执行的。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。第二种是机器级程序使用的内存地址是虚拟地址。

汇编代码表示非常接近于机器代码，与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始C代码的联系，是理解计算机如何执行程序的关键一步。

x86-64机器代码中，一些通常对C语言程序员隐藏的处理器状态都是可见的：

+ 程序计数器给出将要执行的下一条指令在内存中的地址
+ 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些存储器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其它的寄存器用来保存临时数据，例如过程的参数和局部变量，函数的返回值。
+ 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，例如用来实现`if`和`while`语句。
+ 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如x86-64的虚拟地址由64位的字来表示，在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$$2^{48}$$或64TB范围内的一个字节。

一条机器指令只执行一个非常基本的操作，例如将存放在寄存器中的两个数字相加，在存储器和寄存器之间传递数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现程序结构。



## 代码示例

假设我们编写了一个C语言代码文件`mstore.c`，包含如下的函数定义：

```c
long mult2(long, long);

void multstore(long x, long y, long *dest){
    long t = mult2(x, y);
    *dest = t;
}
```

使用`gcc -S mstore.c`产生汇编文件`mstore.s`，其中包括下面几行：

```
multstore:
	pushq   %rbx
	movq    %rdx, %rbx
	call    mult2
	movq    %rax, (%rbx)
	popq    %rbx
	ret
```

以上代码中每个缩进的行都对应于一条机器指令。

如果使用`gcc -c mstore.c`产生目标代码文件`mstore.o`。1368字节的该文件中有一段14字节的序列，其十六进制表示为：

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

这就是上面列出的汇编指令对应的机器代码（目标代码）。从中我们知道，机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

**反汇编器（disassembler）**程序可以根据机器代码产生一种类似汇编代码的格式，在Linux系统中使用`objdump -d mstore.o`反汇编得到如下结果：

```
0000000000000000 <multstore>:

0:   53                       push   %rbx
1:   48 89 d3                 mov    %rdx,%rbx
4:   e8 00 00 00 00           callq  9 <multstore+0x9>
9:   48 89 03                 mov    %rax,(%rbx)
c:   5b                       pop    %rbx
d:   c3                       retq
```

我们看到前面14字节的序列分成了若干组，每组都是一条指令，右边是等价的汇编语言。

其中一些关于机器代码和它的反汇编表示的特性值得注意：

+ x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需的字节数多。
+ 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一解码成机器指令，例如只有指令`push %rbx`是以字节值53开头的。
+ 反汇编器基于机器代码文件中的字节序列来确定汇编代码，它不需要访问程序的源代码或汇编代码，并且反汇编生成的汇编代码与GCC生成的汇编代码有些细微的差别

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个`main`函数。假设文件`main.c`如下：

```c
#include <stdio.h>

void multstore(long, long, long *)
    
int main() {
    long d;
    multstore(2,3,&d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

long mult2(long a, long b) {
    long s = a * b
    return s
}
```

使用`GCC -o prog main.c mstore.c`生成可执行文件`prog`，该文件大小为8655个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来和操作系统交互的代码。

如果使用`objdump -d prog`反汇编`prog`文件，反汇编器会抽取各种代码序列，包括下面这段：

```
0000000000400540 <multstore>:

400540:   53                       push   %rbx
400541:   48 89 d3                 mov    %rdx,%rbx
400544:   e8 00 00 00 00           callq  40058b <mult2>
400549:   48 89 03                 mov    %rax,(%rbx)
40054c:   5b                       pop    %rbx
40054d:   c3                       retq
40054e:   90                       nop
40054f:   90                       nop
```

这段代码与`mstore.o`反汇编产生的代码几乎一样，不同之处包括：左边列出的地址不同——链接器将这段代码的地址移到了一段不同的地址范围中；链接器填上了`callq`指令调用函数`mult2`需要使用的地址（链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置）；多了两行代码——这两条指令的作用是使函数代码变为16字节，使得就存储器性能而言，能更好地放置下一个代码块。



## 关于格式的注解

汇编文件`mstore.s`的完整内容如下：

```
    .file   "010-mstore.c"
    .text
    .globl  multstore
    .type   multstore, @function

multstore:
	pushq   %rbx
	movq    %rdx, %rbx
	call    mult2
	movq    %rax, (%rbx)
	popq    %rbx
	ret
	.size   multstore, .-multstore
	.ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
	.section        .note.GNU-stack,"",@progbits
```

所有以`.`开头的行都是直到汇编器和链接器工作的伪指令，我们通常忽略这些行。

为了更清楚地说明汇编代码，我们使用如图的格式表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/fsgjkiopkjm35kolmklgf.PNG)





# 数据格式

由于起初的体系结构为16位，Intel用“字（word）”表示16位数据类型，因此32位数据类型为“双字（double words）”，64位为“四字（quad words）”。如图所示
C语言基本数据类型对应的x86-64表示。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/sdnjkvnuio35jyhiok35nm.PNG)

大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有4个变种：`movb`，`movw`，`movl`，`movq`。后缀`l`既表示4字节整数也表示8字节双精度浮点数，但这不会产生歧义，因为浮点数使用一组完全不同的指令和寄存器。





# 访问数据

一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。如图显示了这16个寄存器，它们的名字都以`%r`开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/djgfouij5io2jgiowrngjorh.PNG)

如图中嵌套的方框标明的，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置0。

如图右边的解释说明的，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针`%rsp`，用来指明运行时栈的结束位置。另外15个寄存器的用法更灵活，只有少量指令会使用某些特定的寄存器。



## 操作数指示符

大多数指令有一个或多个**操作数（operand）**，指示出执行一个操作要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出；结果可以存放在寄存器或内存中。因此各种不同的操作数的可能性分为三种类型：

1. **立即数（immediate）** 表示常数值。ATT汇编语言中，立即数的书写方式是`$`后面跟一个C语言表示的整数。不同的指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
2. **寄存器（register）** 表示某个寄存器的内容。`R[]`表示寄存器的值。
3. **内存** 根据计算出来的地址（称为有效地址）访问某个内存位置。`M[]`表示内存的值。

如图所示，有多种不同的寻址模式，允许不同形式的内存引用。最常用的是$$Imm(r_b,r_i,s)$$，这样的引用有四个组成部分：一个立即数偏移$$Imm$$，一个基址寄存器$$r_b$$，一个变址寄存器$$r_i$$和一个比例因子s，这里s必须是1，2，4或8。基址寄存器和变址寄存器都必须是64位寄存器。有效地址计算为$$Imm+R[r_b]+R[r]\cdot s$$。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/sdcvjnuiojyh35ionmgjwfrkb.PNG)



## 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

我们把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只是操作数大小不同。

如图所示最简单形式的数据传送指令——MOV类，这些指令把数据从源位置复制到目的位置，不做任何变化。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vdhnuiojenthio35jhqrgw.PNG)

源操作数指定的值是一个立即数，存储在寄存器中或者内存中；目的操作数指定一个位置，是一个寄存器或者内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置，将一个值从一个内存位置复制到另一个内存位置需要两条指令和一个寄存器。

下图记录了两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（寄存器或内存）复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，即复制源值的最高位。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/sdfgjiok36mjklhetml.PNG)



## 数据传送示例

作为一个使用数据传送指令的代码示例，考虑如下的数据交换函数，既有C代码，又有GCC产生的汇编代码：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/dgfjsionm25jklnmwgthr.PNG)

如图所示，函数`exchange`由三条指令实现：两个数据传送（`movq`），以及返回函数被调用点（`ret`）。当过程开始执行时，过程参数`xp`和`y`分别存储在寄存器`%rdi`和`%rsi`中，然后指令2从内存中读出`x`并存放到寄存器`%rax`中。稍后函数返回寄存器`%rax`的值，因而返回了`x`。指令3将`y`写入寄存器`$rdi`中`xp`指向的内存位置。

关于这段汇编代码有两点值得注意：首先C语言的指针其实就是地址，使用指针就是将地址存放在一个寄存器中，然后在内存引用中使用这个寄存器；其次像`x`这样的局部变量通常是保存在寄存器中而不是内存中，因为访问寄存器比访问内存要快得多。



## 压入和弹出栈数据

最后两个数据传送操作是将数据压入程序栈中，以及从程序栈中弹出数据。在x86-64中，程序栈存放在内存中某个区域，如图所示，栈向下增长，这样一来栈顶元素的地址是栈中所有元素地址中最低的。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/sjcmvkioljnuio35yhjuiot3.PNG)

因为栈和程序代码以及其它形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置，例如指令`movq 8(%rsp),%rdx`会将栈顶的第二个元素从栈中复制到寄存器`%rdx`。





# 算术和逻辑操作

如图所示x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/xfngvjinjir3hui245tty25.PNG)



## 加载有效地址

**加载有效地址（load effective address）**指令`leaq`实际上是`movq`指令的变形。该指令并没有真正去引用内存，而只是将内存地址复制到寄存器。编译器经常发现`leaq`的一些灵活用法，根本就与有效地址计算无关，例如如果寄存器`%rdi`的值为`x`，寄存器`%rsi`的值为`y`，那么指令`leaq 7(%rdi,%rsi,4),%rax`将设置寄存器`%rax`的值为`5x+7`。



## 一元操作和二元操作

一元操作只有一个操作数，既是源又是目的，操作数可以是寄存器或内存位置。`INC`类指令和`DEC`类指令对应C语言的`++`和`--`运算符。

二元操作的第二个操作数既是源又是目的，第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。



## 移位操作

移位操作的第一个操作数是移位量，第二个操作数是要移位的数，可以进行算术和逻辑右移。移位量可以是立即数，或者放在单字节寄存器`%cl`中（只允许使用这个寄存器）。移位操作的目的数可以是一个寄存器或内存位置。原则上来说，1个字节的移位量使得移位量的编码范围可以达到255，x86-64中，移位操作对w位长的数据值进行操作，移位量是w除`%cl`的余数。因此，当寄存器`%cl`的十六进制值为`0xFF`时，指令`salb`会移7位，`salw`会移15位，`sall`会移31位，而`salq`会移63位。

左移指令`SAL`和`SHL`的效果是一样的。右移指令中，`SAR`执行算术右移，`SHR`执行逻辑右移。



## 讨论

以上算术和逻辑操作既可以用于无符号运算，也可以用于补码运算，只有右移操作要求区分有符号和无符号数。这一特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。



## 特殊的算术操作

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位数的操作提供有限的支持。Intel把16字节的数称为**八字（oct word）**。如图所示支持产生两个64位数字的128位乘积以及整数除法的指令。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/nvjkiowrhjio35jyio35.PNG)

指令`mulq`和`imulq`用于计算两个64位值的全128位乘积，这两条指令都要求一个参数必须在寄存器`%rax`中，而另一个作为指令的源操作数给出，最后乘积放在寄存器`%rdx`（高位）和`%rax`（低位）中。

下面这段C代码说明了如何从两个无符号64位数字`x`和`y`生成128位的乘积：

```c
#include <inttypes.h>

typedef unsigned __int128 uint128_t;

void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){
    *dest = x * (uint128_t) y;
}
```

GCC生成的汇编代码如下：

图

可以观察到，存储乘积需要两个`movq`指令。由于生成这段代码针对小端法机器，所以高位字节存储在大地址。

有符号除法指令`idivl`将寄存器`%rdx`（高64位）和`%rax`（低64位）中的128位数作为被除数，除数作为指令的操作数给出，最后的商存储在寄存器`%rax`中，余数存储在寄存器`%rdx`中。

下面这段C代码说明了如何计算两个有符号64位数`x`和`y`的商和余数：

```c
void remdiv(long x, long y, long *qp, long *rp) {
    long q = x/y;
    long r = x%y;
    *qp = q;
    *rp = r;
}
```

编译得到如下汇编代码：

图

第4行将被除数符号扩展到`%rdx`。



## 控制

C语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件地执行，根据数据测试的结果决定操作执行的顺序。机器





## 条件码

除了整数寄存器，CPU还维护着一组单个位的**条件码（condition code）**寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。最常用的条件码有：

+ `CF`：进位标志：最近的操作使最高位产生了进位。可用来检查无符号操作的溢出
+ `ZF`：零标志：最近的操作得出的结果为0
+ `SF`：符号标志：最近的操作得到的结果为负数
+ `OF`：溢出标志：最近的操作导致一个补码溢出

例如用一条ADD指令完成`t=a+b`的功能，这里`a`，`b`，`t`都是整型的（无符号或有符号），然后可以根据下面的C表达式来设置条件码：

```
CF  (unsigned) t < (unsigned) a       //无符号整数，检查溢出
ZF  (t == 0)                          //零
SF  (t < 0)                           //负数
OF  (a<0 == b<0) && (t<0 != a<0)      //有符号整数，检查上溢和下溢
```

算术操作中的所有指令，除了`leaq`，都会设置条件码；对于逻辑操作，进位标志和溢出标志会被置为0；对于移位操作，进位标志将置为最后一个被移出的位，而溢出标志置为0；`INC`和`DEC`指令会设置溢出和零标志，但是不会改变进位标志。

此外，还有两类指令只设置条件码而不改变任何其它寄存器，如图所示：`CMP`指令根据两个操作数之差来设置条件码，其行为与`SUB`指令的行为类似，只是不更新目的寄存器；`TEST`指令行为与`AND`指令的行为类似。

图



## 访问条件码

条件码常见的使用方法有三种：

1. 根据条件码的某种组合，将一个字节置为0或1；
2. 条件跳转到程序的某个其它的部分；
3. 有条件地传送数据；

将一个字节置为0或1的一整类指令称为SET指令，它们之间的区别就在于它们考虑的条件码的组合是什么，指令的后缀即是表示不同的条件。

图

一条SET指令的目的操作数是低位单字节寄存器元素之一，或者一个字节的内存位置，指令将这个字节置为0或1。为了得到一个32位或64位的结果，我们需要对高位清零。一个计算`a < b`的典型指令序列如下所示，这里`a`和`b`都是`long`类型：

图

注意`movzbl`会将寄存器`%rax`的高7个字节全部清零。

虽然所有的算术和逻辑操作都会设置条件码，但是各个SET命令的描述只是适用于：执行比较指令，根据计算`t=a-b`设置条件码，其中`a, b, t`都是补码形式的整数。其它情形需要比照这一情形。

